<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="XiaoLong Li">





<title>JUC并发编程 | XL</title>



    <link rel="icon" href="/2.png">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">XL&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">XL&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">JUC并发编程</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">XiaoLong Li</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">April 13, 2025&nbsp;&nbsp;10:02:11</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Java/">Java</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="JUC介绍"><a href="#JUC介绍" class="headerlink" title="JUC介绍"></a>JUC介绍</h1><p>JUC指的是：Java里的三个包<br>java.util.concurrent<br>java.util.concurrent.atomic：原子性<br>java.util.concurrent.locks：lock锁</p>
<blockquote>
<p>问题：Java真的可以开启线程吗？</p>
</blockquote>
<p>Java创建Thread类调用start方法，底层是把线程放到一个组里面，然后调用一个本地方法start0；方法底层是C++；Java无法操作硬件。</p>
<h1 id="多线程回顾"><a href="#多线程回顾" class="headerlink" title="多线程回顾"></a>多线程回顾</h1><h2 id="多线程的几种状态"><a href="#多线程的几种状态" class="headerlink" title="多线程的几种状态"></a>多线程的几种状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尚未启动的线程的线程状态。新生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可运行线程的线程状态。</span></span><br><span class="line"><span class="comment">     * 处于可运行状态的线程，正在Java虚拟机中执行，</span></span><br><span class="line"><span class="comment">     * 但它可能正在等待来自操作系统的其他资源，例如处理器。运行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待监视器锁而阻塞的线程的线程状态。</span></span><br><span class="line"><span class="comment">     * 处于阻塞状态的线程正在等待监视器锁进入同步块/方法，或者在调用后重新进入同步块/方法。阻塞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待线程的线程状态。</span></span><br><span class="line"><span class="comment">     * 线程处于等待状态，因为调用了一个以下方法：</span></span><br><span class="line"><span class="comment">     * Object.wait、Thread.join、LockSupport.park。等待，死死的等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具有指定等待时间的等待线程的线程状态。</span></span><br><span class="line"><span class="comment">     * 线程处于定时等待状态，因为调用了以下方法与指定的正等待时间:</span></span><br><span class="line"><span class="comment">     * Thread.sleep、Object.wait(long)、Thread.join(long)、LockSupport.parkNanos、LockSupport.parkUntil</span></span><br><span class="line"><span class="comment">     *   超时等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 终止线程的线程状态。</span></span><br><span class="line"><span class="comment">     * 线程已完成执行。终止</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sleep-wait的区别"><a href="#sleep-wait的区别" class="headerlink" title="sleep&amp;wait的区别"></a>sleep&amp;wait的区别</h2><ol>
<li>sleep是Thread类的本地方法；wait是Object类的方法。</li>
<li>sleep不释放锁；wait释放锁。</li>
<li>sleep不需要和synchronized关键字一起使用；wait必须和synchronized代码块一起使用。</li>
<li>sleep不需要被唤醒（时间到了自动退出阻塞）；wait需要被唤醒。</li>
<li>sleep一般用于当前线程休眠，或者轮循暂停操作；wait则多用于多线程之间的通信。</li>
</ol>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p><img src="/.com//blog\source_posts\JUC并发编程\image-20250413203400885.png" alt="image-20250413203400885"></p>
<h2 id="传统的synchronized锁"><a href="#传统的synchronized锁" class="headerlink" title="传统的synchronized锁"></a>传统的synchronized锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者消费者问题</span></span><br><span class="line"><span class="comment">//线程A B操作同一个变量，A增加完成之后通知B减少</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     data.increment();</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     data.decrement();</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     data.increment();</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     data.decrement();</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;, <span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 流程：判断等待，业务，通知</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="comment">// +1</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">         <span class="keyword">while</span> (i != <span class="number">0</span>) &#123;<span class="comment">//这里while如果是if的话，A、B、C、D四个线程，会存在虚假唤醒问题！所以等待应该出现在循环中。</span></span><br><span class="line">             <span class="built_in">this</span>.wait();</span><br><span class="line">         &#125;</span><br><span class="line">         i++;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + i);</span><br><span class="line">         <span class="comment">// 通知其他线程我+1完成</span></span><br><span class="line">         <span class="built_in">this</span>.notifyAll();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// -1</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">         <span class="keyword">while</span> (i==<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="built_in">this</span>.wait();</span><br><span class="line">         &#125;</span><br><span class="line">         i--;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + i);</span><br><span class="line">         <span class="comment">// 通知其他线程，我-1完毕</span></span><br><span class="line">         <span class="built_in">this</span>.notifyAll();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="公平锁和非公平锁（锁的底层）"><a href="#公平锁和非公平锁（锁的底层）" class="headerlink" title="公平锁和非公平锁（锁的底层）"></a>公平锁和非公平锁（锁的底层）</h2><p>公平锁：十分公平，不能插队。<br>非公平锁：十分不公平，可以插队。（默认非公平锁）</p>
<h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><p>Lock锁是一个接口，他有三个实现类：</p>
<ul>
<li>ReentrantLock类</li>
<li>ReentrantReadWriteLock.ReadLock</li>
<li>ReentrantReadWriteLock.WriteLock</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JUC版生产者消费者问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 data.increment();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 data.decrement();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 data.increment();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 data.decrement();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;D&quot;</span>).start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断等待，业务，通知</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"> <span class="comment">// +1</span></span><br><span class="line"> <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">             condition.await();<span class="comment">//等待</span></span><br><span class="line">         &#125;</span><br><span class="line">         i++;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + i);</span><br><span class="line">         <span class="comment">// 通知其他线程我+1完成</span></span><br><span class="line">         condition.signalAll();<span class="comment">//唤醒全部</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// -1</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (i==<span class="number">0</span>)&#123;</span><br><span class="line">             condition.await();</span><br><span class="line">         &#125;</span><br><span class="line">         i--;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + i);</span><br><span class="line">         <span class="comment">// 通知其他线程，我-1完毕</span></span><br><span class="line">         condition.signalAll();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lock锁和synchronized的区别"><a href="#Lock锁和synchronized的区别" class="headerlink" title="Lock锁和synchronized的区别"></a>Lock锁和synchronized的区别</h2><ol>
<li>Synchronized是内置Java关键字；Lock是一个Java类。</li>
<li>Synchronized无法判断获取锁的状态；Lock可以判断是否获取到了锁。（boolean b &#x3D; lock.tryLock();）</li>
<li>Synchronized会自动释放锁；Lock必须要手动释放锁，如果不释放锁，死锁。</li>
<li>Synchronized线程1获得锁阻塞时，线程2会一直等待下去；Lock锁线程1获得锁阻塞时，线程2等待足够长的时间后中断等待，去做其他的事。</li>
<li>Synchronized可重入锁，不可以中断的，非公平；Lock，可重入锁，可以判断锁，非公平（可以自己设置）。<br>lock.lockInterruptibly();方法：当两个线程同时通过该方法想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</li>
<li>Synchronized适合锁少量的代码同步问题；Lock适合锁大量的同步代码。</li>
</ol>
<h2 id="Condition实现精准通知和唤醒线程"><a href="#Condition实现精准通知和唤醒线程" class="headerlink" title="Condition实现精准通知和唤醒线程"></a>Condition实现精准通知和唤醒线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data01</span> <span class="variable">data01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data01</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data01.A();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data01.B();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data01.C();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断等待，业务，通知</span></span><br><span class="line"><span class="comment">//A执行完调用B，B执行完调用C，C执行完调用A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data01</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">// num为1则A执行 2：B 3：C</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务代码，判断=&gt;执行=&gt;通知！</span></span><br><span class="line">            <span class="keyword">while</span> (num!=<span class="number">1</span>)&#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;AAAAA&quot;</span>);</span><br><span class="line">            num = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 唤醒指定的线程，B</span></span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">B</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num!=<span class="number">2</span>)&#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">3</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;BBBBB&quot;</span>);</span><br><span class="line">            <span class="comment">// 唤醒指定的线程，C</span></span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">C</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num!=<span class="number">3</span>)&#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;CCCCC&quot;</span>);</span><br><span class="line">            <span class="comment">// 唤醒指定的线程，A</span></span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8锁现象"><a href="#8锁现象" class="headerlink" title="8锁现象"></a>8锁现象</h1><p>指的<strong>是在多线程环境下，当多个线程同时对同一个对象的不同锁进行操作时，可能导致性能下降的现</strong>象</p>
<p>案例一：</p>
<p>synchronized 锁的对象是方法的调用者，在这里是锁的phone。hello() 没有锁！不是同步方法，所以不受锁的影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="comment">//锁的存在</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 捕获</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.call();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="comment">// synchronized 锁的对象是方法的调用者！、</span></span><br><span class="line">    <span class="comment">// 两个方法用的是同一个锁，谁先拿到谁执行！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里没有锁！不是同步方法，不受锁的影响</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例二：</p>
<p>静态的同步方法 锁的是 Class 类模板，普通的同步方法  锁的是调用者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 两个对象的Class类模板只有一个，static上面加synchronized锁的是Class</span></span><br><span class="line">        <span class="type">Phone4</span> <span class="variable">phone1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone4</span>();</span><br><span class="line">        <span class="type">Phone4</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone4</span>();</span><br><span class="line">        <span class="comment">//锁的存在</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone1.sendSms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 捕获</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone2.call1/<span class="number">2</span>();<span class="comment">//调用call1(静态的同步方法,都属于类模板) 则输出结果是：先输出发短信 再输出打电话</span></span><br><span class="line">            				<span class="comment">//调用call2(普通的同步方法) 则输出结果是：先输出打电话 再输出发短信</span></span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Phone4唯一的一个 Class 对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone4</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的同步方法 锁的是 Class 类模板</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态的同步方法  锁的调用者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通的同步方法  锁的调用者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果先输出“打电话”  再输出“发短信”  因为锁的不是一个对象，call方法不用等待sendSms方法</p>
<blockquote>
<p>锁的对象:</p>
<p>new this 是具体的一个手机</p>
<p>static Class 是唯一的一个模板</p>
</blockquote>
<h1 id="集合类不安全"><a href="#集合类不安全" class="headerlink" title="集合类不安全"></a>集合类不安全</h1><p>多线程下不安全；可能会报错：java.util.ConcurrentModificationException（并发修改异常）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.ConcurrentModificationException：并发修改异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                strings.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(strings);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<ol>
<li>List<String> list &#x3D; new Vector&lt;&gt;();</String></li>
<li>List<String> strings &#x3D; Collections.synchronizedList(new ArrayList&lt;&gt;());</String></li>
<li>List<String> strings &#x3D; new CopyOnWriteArrayList&lt;&gt;();</String></li>
</ol>
<p>概念：CopyOnWrite：写入时复制，计算机程序设计语言的一种优化策略。(保证效率和性能问题)。在写入的时候避免覆盖，造成数据问题。Vector是使用synchronized实现的安全，效率不高。CopyOnWriteArrayList是使用Lock锁实现的安全。</p>
<blockquote>
<p><strong>注：</strong>Set和List类似，也是不安全的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.ConcurrentModificationException：并发修改异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Set&lt;String&gt; strings = Collections.synchronizedSet(new HashSet&lt;&gt;());</span></span><br><span class="line">        HashSet&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                strings.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(strings);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<ol>
<li>Set<String> strings &#x3D; Collections.synchronizedSet(new HashSet&lt;&gt;());</String></li>
<li>Set<String> strings &#x3D; new CopyOnWriteArraySet&lt;&gt;();</String></li>
</ol>
<p>hashset集合的底层是hashmap的key</p>
<blockquote>
<p> HasMap 集合</p>
</blockquote>
<p>多线程下不安全；可能会报错：java.util.ConcurrentModificationException（并发修改异常）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.ConcurrentModificationException：并发修改异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 默认相当于</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>, <span class="number">0.75F</span>);<span class="comment">//默认的初始容量和加载因子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(),UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<ol>
<li>使用Map&lt;String, String&gt; <strong>concurrentHashMap</strong> &#x3D; new ConcurrentHashMap&lt;&gt;();</li>
<li>Collections.synchronizedMap</li>
</ol>
<h1 id="Callable"><a href="#Callable" class="headerlink" title="Callable()"></a>Callable()</h1><p>Callable 接口类似于 Runnable，线程第三种创建方式。但是 Runnable 不会返回结果，并且无法抛出经过检查的异常，而 Callable 依赖 FutureTask 类获取返回结果。结合 <code>ExecutorService</code> 和 <code>Future</code>，可以轻松实现复杂的异步任务管理。</p>
<ol>
<li>可以抛出异常。</li>
<li>可以有返回值。</li>
<li>方法不同与Runnable接口。Call方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>());<span class="comment">// 适配类</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;B&quot;</span>).start();<span class="comment">// 打印一个Call，结果会被缓存，提高效率</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">s</span> <span class="operator">=</span> (Integer) futureTask.get();<span class="comment">// get方法可能会产生阻塞</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Call&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p><code>Future</code> 是一个接口，用于表示一个异步计算的结果。它提供了一些方法来检查任务是否完成、取消任务以及获取任务的执行结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>; <span class="comment">// 取消任务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;                        <span class="comment">// 检查任务是否已被取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;                             <span class="comment">// 检查任务是否已完成</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException; <span class="comment">// 获取结果</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException; <span class="comment">// 带超时的获取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li>仅是一个接口，不能直接用于实例化。</li>
<li>通常通过 <code>ExecutorService</code> 提交任务后返回一个 <code>Future</code> 对象来管理任务。</li>
</ul>
<p><strong>Future示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交一个 Callable 任务，返回 Future 对象</span></span><br><span class="line">        Future&lt;String&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Task completed!&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Task submitted.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 检查任务状态</span></span><br><span class="line">            <span class="keyword">if</span> (!future.isDone()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task is not completed yet.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取结果（会阻塞直到任务完成）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;Task result: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Task submitted.</span><br><span class="line">Task is not completed yet.</span><br><span class="line">Task result: Task completed!</span><br></pre></td></tr></table></figure>

<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p><code>FutureTask</code> 是 <code>Future</code> 接口的实现类，同时也是一个 <code>Runnable</code>，可以作为任务提交给线程或线程池。</p>
<p><strong>特点</strong></p>
<ul>
<li>既是一个任务 (<code>Runnable</code>)，也可以用来获取异步计算的结果 (<code>Future</code>)。</li>
<li>可以直接用 <code>Thread</code> 执行，也可以提交给 <code>ExecutorService</code>。</li>
</ul>
<p><strong>构造方法</strong></p>
<p><code>FutureTask</code> 提供了两种构造方法：</p>
<ol>
<li>接收一个 <code>Callable</code> 对象。</li>
<li>接收一个 <code>Runnable</code> 对象和一个返回值。</li>
</ol>
<p><strong>FeatureTask结合线程池使用示例(也可以结合线程)：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskWithExecutor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Task completed via executor!&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executor.submit(futureTask);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Result: &quot;</span> + futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Future-FutureTask对比"><a href="#Future-FutureTask对比" class="headerlink" title="Future&amp;FutureTask对比"></a>Future&amp;FutureTask对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th><code>Future</code></th>
<th><code>FutureTask</code></th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>接口</td>
<td>类，实现了 <code>Future</code> 和 <code>Runnable</code></td>
</tr>
<tr>
<td>获取结果</td>
<td><code>Future#get()</code> 方法</td>
<td><code>FutureTask#get()</code> 方法</td>
</tr>
<tr>
<td>提交任务方式</td>
<td>通过 <code>ExecutorService</code> 提交</td>
<td>可通过 <code>ExecutorService</code> 或线程</td>
</tr>
<tr>
<td>是否可直接执行</td>
<td>否，<code>Future</code> 只是结果的容器</td>
<td>是，<code>FutureTask</code> 可直接作为任务</td>
</tr>
<tr>
<td>典型用途</td>
<td>检查任务状态、获取异步结果</td>
<td>定义和管理异步任务</td>
</tr>
</tbody></table>
<h1 id="常用辅助类"><a href="#常用辅助类" class="headerlink" title="常用辅助类"></a>常用辅助类</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 总数是6，必须要是执行任务的时候使用</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;Go Out&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();<span class="comment">// 数量-1</span></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();<span class="comment">// 等待计数器归零，然后再往下执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;关门&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2022/01/14/kuangstudy6401a136-039f-4e70-956e-c0eaeee6d855.jpg" alt="img"></p>
<blockquote>
<p>countDownLatch.countDown(): 每次有线程调用，数量-1，</p>
<p>countDownLatch.await(): 当计数器归零，countDownLatch.await()就会被唤醒向下执行。</p>
</blockquote>
<p>应用场景：1.多线程任务汇总。2.多线程任务阻塞住，等待发令枪响，一起执行。</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>用于让一组线程相互等待，直到它们都到达某个共同的屏障点（barrier）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于加法计数器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 集齐七颗龙珠召唤神龙</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">7</span>, () -&gt; &#123;<span class="comment">//这里指定了回调函数，当所有线程到达屏障点时会执行</span></span><br><span class="line">            <span class="comment">// 如果计数器为7，线程只有6个，则会等待，不进行召唤神龙</span></span><br><span class="line">            System.out.println(<span class="string">&quot;召唤神龙&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;收集&quot;</span> + temp + <span class="string">&quot;个龙珠！&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();<span class="comment">//等待数量到达7之后才执行CyclicBarrier里的函数</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2022/01/14/kuangstudyf20aa214-40fc-4922-beca-5562c113f218.jpg" alt="img"></p>
<p>应用场景：比如LOL类游戏，满10人一组，开始游戏。</p>
<p><strong>核心方法</strong></p>
<ol>
<li><strong><code>await()</code></strong><ul>
<li>每个线程调用 <code>await()</code> 方法表示到达屏障点。</li>
<li>当指定数量的线程都调用 <code>await()</code> 后，屏障解除，所有线程继续执行。</li>
<li><code>await()</code> 可能会抛出以下异常：<ul>
<li><code>BrokenBarrierException</code>：如果屏障被重置或中断。</li>
<li><code>InterruptedException</code>：如果线程在等待时被中断。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>reset()</code></strong><ul>
<li>重置屏障到初始状态。</li>
<li>可以用于再利用 <code>CyclicBarrier</code>。</li>
</ul>
</li>
<li><strong><code>getParties()</code></strong><ul>
<li>返回需要等待的线程数量。</li>
</ul>
</li>
<li><strong><code>getNumberWaiting()</code></strong><ul>
<li>返回当前已经到达屏障点的线程数量。</li>
</ul>
</li>
</ol>
<h2 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h2><p>semaphore.acquire();获得，假设已经满了则等待，等待其他线程释放。<br>semaphore.release();释放，会将当前的信号量释放+1，然后唤醒等待的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 线程数量：停车位！限流</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();<span class="comment">// 得到</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;抢到车位！&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;离开车位！&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();<span class="comment">// 释放</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2022/01/14/kuangstudy64ec8b72-ce51-44c6-b207-4e3d1ffbaa39.jpg" alt="img"></p>
<h1 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h1><p>ReadWriteLock接口有一个实现类ReentrantReadWriteLock类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 独占锁（写锁）：一次只能被一个线程占有</span></span><br><span class="line"><span class="comment"> * 共享锁（读锁）：多个线程可以同时占有</span></span><br><span class="line"><span class="comment"> * ReentrantLock:</span></span><br><span class="line"><span class="comment"> * 读-读：可以共存</span></span><br><span class="line"><span class="comment"> * 读-写：不可以共存</span></span><br><span class="line"><span class="comment"> * 写-写：不可以共存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCacheLock</span> <span class="variable">myCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCacheLock</span>();</span><br><span class="line">        <span class="comment">// 5个线程写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myCache.put(temp + <span class="string">&quot;&quot;</span>, temp + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5个线程读</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myCache.get(temp + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCacheLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 读写锁，更加细粒度的控制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">// 写，同时只有一个线程写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object obj)</span> &#123;</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写入&quot;</span>);</span><br><span class="line">            map.put(key, obj);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写入OK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读，所有线程都可以读</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读取&quot;</span>);</span><br><span class="line">            map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读取OK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p> ArrayBlockingQueue的不同添加和移除方法，在面对队列满或者空时不同的操作。</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>抛出异常</th>
<th>有返回值，不抛出异常</th>
<th>阻塞，一直等待</th>
<th>阻塞，超时等待</th>
</tr>
</thead>
<tbody><tr>
<td>添加</td>
<td>add()</td>
<td>offer()</td>
<td>put()</td>
<td>offer(，，)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>pull()</td>
<td>take()</td>
<td>pull(，)</td>
</tr>
<tr>
<td>检测队首元素</td>
<td>element()</td>
<td>peek()</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayBlockingQueue</span> <span class="variable">blockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">blockingQueue.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">blockingQueue.remove();</span><br><span class="line">..........</span><br></pre></td></tr></table></figure>

<p><strong>SynchronousQueue同步队列：</strong>进去一个元素，必须等待取出这个元素后，才能放下一个元素。用的是put()、take()</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>3大方法、7大参数、4大拒绝策略</p>
<h2 id="Executors-工具类提供的三种常用线程池的创建方法"><a href="#Executors-工具类提供的三种常用线程池的创建方法" class="headerlink" title="Executors 工具类提供的三种常用线程池的创建方法"></a><strong><code>Executors</code></strong> 工具类提供的三种常用线程池的创建方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">//本质都是调用的ThreadPoolExecutor</span></span><br><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is executing task&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">executor.shutdown();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><strong><code>Executors.newSingleThreadExecutor()</code></strong></li>
</ol>
<p><strong>功能</strong>：创建一个单线程的线程池。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>线程池中始终只有一个线程。</li>
<li>如果线程异常终止，会创建一个新的线程来代替。</li>
<li>任务会按照提交顺序执行（FIFO，先进先出）。</li>
</ul>
<p><strong>适用场景</strong>：需要按顺序执行任务，并确保一次只执行一个任务。</p>
<ol start="2">
<li><strong><code>Executors.newFixedThreadPool(int nThreads)</code></strong></li>
</ol>
<p><strong>功能</strong>：创建一个固定大小的线程池。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>指定线程池中的线程数（<code>nThreads</code>）。</li>
<li>超过线程池容量的任务会进入任务队列等待执行。</li>
<li>线程池中的线程会被重用，减少线程创建的开销。</li>
</ul>
<p><strong>适用场景</strong>：执行固定数量的任务，或对线程数量有明确限制的场景。</p>
<ol start="3">
<li><strong><code>Executors.newCachedThreadPool()</code></strong></li>
</ol>
<ul>
<li><strong>功能</strong>：创建一个可以根据需要动态调整线程数的线程池。</li>
<li><strong>特点</strong>：<ul>
<li><strong>无核心线程数（<code>corePoolSize=0</code>），最大线程数为无界</strong>。</li>
<li>空闲线程超过 60 秒会被回收。</li>
<li>如果有任务提交，且没有空闲线程，则会创建新线程。</li>
<li>适合执行大量短期异步任务。</li>
</ul>
</li>
<li><strong>适用场景</strong>：任务量多但任务执行时间较短的场景。</li>
</ul>
<h3 id="其他辅助方法"><a href="#其他辅助方法" class="headerlink" title="其他辅助方法"></a><strong>其他辅助方法</strong></h3><p>除了上面三种常用方法，<code>Executors</code> 工具类还提供了其他线程池创建方法：</p>
<ul>
<li>**<code>Executors.newScheduledThreadPool(int corePoolSize)</code>**：<ul>
<li>创建一个支持定时任务和周期性任务的线程池。</li>
</ul>
</li>
<li>**<code>Executors.newWorkStealingPool(int parallelism)</code>**：<ul>
<li>基于 <code>ForkJoinPool</code>，使用工作窃取算法，适合大任务拆分为小任务执行。</li>
</ul>
</li>
</ul>
<h3 id="避免直接使用-Executors-创建线程池："><a href="#避免直接使用-Executors-创建线程池：" class="headerlink" title="避免直接使用 Executors 创建线程池："></a><strong>避免直接使用 <code>Executors</code> 创建线程池</strong>：</h3><p>在实际开发中，不推荐直接使用 <code>Executors</code> 工具类创建线程池，因为它可能存在以下问题：</p>
<ol>
<li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code> 使用的阻塞队列是无界队列</strong>：<ul>
<li>可能导致 OOM（内存溢出）风险。</li>
</ul>
</li>
<li><strong><code>CachedThreadPool</code> 的线程数没有上限</strong>：<ul>
<li>如果任务提交速度远大于任务处理速度，可能导致系统崩溃。</li>
</ul>
</li>
</ol>
<h3 id="替代方案：使用-ThreadPoolExecutor"><a href="#替代方案：使用-ThreadPoolExecutor" class="headerlink" title="替代方案：使用 ThreadPoolExecutor"></a><strong>替代方案：使用 <code>ThreadPoolExecutor</code></strong></h3><p>推荐通过 <code>ThreadPoolExecutor</code> 显式创建线程池，可以完全控制线程池参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java复制编辑ExecutorService executor = new ThreadPoolExecutor(</span><br><span class="line">    2,                      // 核心线程数</span><br><span class="line">    5,                      // 最大线程数</span><br><span class="line">    60L,                    // 空闲线程存活时间</span><br><span class="line">    TimeUnit.SECONDS,       // 时间单位</span><br><span class="line">    new LinkedBlockingQueue&lt;&gt;(100), // 阻塞队列</span><br><span class="line">    Executors.defaultThreadFactory(), // 线程工厂</span><br><span class="line">    new ThreadPoolExecutor.CallerRunsPolicy() // 拒绝策略</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这样可以根据实际需求灵活调整线程池的行为。</p>
<h2 id="七大参数"><a href="#七大参数" class="headerlink" title="七大参数"></a>七大参数</h2><p>以上三种方法都是用ThreadPoolExecutor实现的，只是传递了不同的参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> corePoolSize,       // 核心线程数</span></span><br><span class="line"><span class="params">    <span class="type">int</span> maximumPoolSize,    // 最大线程数</span></span><br><span class="line"><span class="params">    <span class="type">long</span> keepAliveTime,     // 空闲线程存活时间</span></span><br><span class="line"><span class="params">    TimeUnit unit,          // 时间单位</span></span><br><span class="line"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue, // 阻塞队列</span></span><br><span class="line"><span class="params">    ThreadFactory threadFactory,       // 线程工厂，创建线程的，一般不用动.一般用于设置线程的名字或配置守护线程。</span></span><br><span class="line"><span class="params">    RejectedExecutionHandler handler   // 拒绝策略</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p>当候客区（阻塞队列）也满的时候，Max线程池则开启。</p>
<p><img src="/.com//blog\source_posts\JUC并发编程\image-20250414160158834.png" alt="image-20250414160158834"></p>
<h2 id="四大拒绝策略"><a href="#四大拒绝策略" class="headerlink" title="四大拒绝策略"></a>四大拒绝策略</h2><p>ThreadPoolExecutor里面的一个参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy(); <span class="comment">// 抛出异常</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy();<span class="comment">// 哪来的去哪（主线程来的，就回去让主线程执行）</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy();<span class="comment">// 丢掉任务，不抛出异常</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy();<span class="comment">// 尝试和最早的竞争，竞争失败了也丢掉任务，也不抛出异常</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>小结和拓展</strong></p>
<p>最大线程应该如何设置?</p>
</blockquote>
<ol>
<li>CPU密集型：最大线程数，CPU几核的就是几，可以保持CPU效率最高。</li>
<li>IO密集型：判断程序中十分耗IO的线程数量，大于这个数，一般是这个数的两倍。</li>
</ol>
<h1 id="四大函数式接口"><a href="#四大函数式接口" class="headerlink" title="四大函数式接口"></a>四大函数式接口</h1><p>新时代程序员必须掌握：lambda表达式、链式编程(将多个方法调用串联在一起的编程风格)、函数式接口、stream流式计算。<br>函数式接口：只有一个方法的接口。</p>
<h2 id="Function函数型接口"><a href="#Function函数型接口" class="headerlink" title="Function&lt;T, R&gt;函数型接口"></a>Function&lt;T, R&gt;函数型接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R <span class="title function_">apply</span><span class="params">(T t)</span>;<span class="comment">//对应的抽象方法</span></span><br></pre></td></tr></table></figure>

<p>有一个输入参数，有一个输出（返回值）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, String&gt; intToString = i -&gt; <span class="string">&quot;Number: &quot;</span> + i;<span class="comment">//lambda表达式</span></span><br><span class="line">System.out.println(intToString.apply(<span class="number">5</span>));  <span class="comment">// 输出：Number: 5</span></span><br></pre></td></tr></table></figure>

<h2 id="Predicate断定型接口"><a href="#Predicate断定型接口" class="headerlink" title="Predicate断定型接口"></a>Predicate<T>断定型接口</T></h2><p>有一个输入参数，返回值只能是boolean值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;<span class="comment">//对应的抽象方法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Integer&gt; isEven = num -&gt; num % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">System.out.println(isEven.test(<span class="number">4</span>));  <span class="comment">// 输出：true</span></span><br><span class="line">System.out.println(isEven.test(<span class="number">5</span>));  <span class="comment">// 输出：false</span></span><br></pre></td></tr></table></figure>

<h2 id="Consumer消费型接口"><a href="#Consumer消费型接口" class="headerlink" title="Consumer消费型接口"></a>Consumer<T>消费型接口</T></h2><p>有一个输入参数，没有返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;<span class="comment">//对应的抽象方法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; printString = str -&gt; System.out.println(str);</span><br><span class="line">printString.accept(<span class="string">&quot;Hello, World!&quot;</span>);  <span class="comment">// 输出：Hello, World!</span></span><br></pre></td></tr></table></figure>

<h2 id="Supplier供给型接口"><a href="#Supplier供给型接口" class="headerlink" title="Supplier供给型接口"></a>Supplier<T>供给型接口</T></h2><p>没有输入参数，有一个输出（返回值）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">get</span><span class="params">()</span>;<span class="comment">//对应的抽象方法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Integer&gt; getRandomNumber = () -&gt; (<span class="type">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">System.out.println(getRandomNumber.get());  <span class="comment">// 输出：0到99之间的随机整数</span></span><br></pre></td></tr></table></figure>

<h1 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h1><p>Stream 的核心理念是将<strong>数据流</strong>与操作分离，通过流式计算对数据执行一系列的操作，例如过滤、映射、排序、聚合等，而不会改变原始数据源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目要求：一分钟内完成此题，只能用一行代码实现！</span></span><br><span class="line"><span class="comment"> * 现在有5个用户！筛选：</span></span><br><span class="line"><span class="comment"> * 1、密码必须是偶数</span></span><br><span class="line"><span class="comment"> * 2、年龄必须大于23岁</span></span><br><span class="line"><span class="comment"> * 3、用户名转为大写字母</span></span><br><span class="line"><span class="comment"> * 4、用户名字母倒着排序</span></span><br><span class="line"><span class="comment"> * 5、只输出一个用户！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//mysql和集合本质是来放东西  计算的东西应该交给流</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User1</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User1</span>(<span class="string">&quot;qk1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="number">21</span>);</span><br><span class="line">        <span class="type">User1</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User1</span>(<span class="string">&quot;Hk2&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        <span class="type">User1</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User1</span>(<span class="string">&quot;kk3&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        <span class="type">User1</span> <span class="variable">u4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User1</span>(<span class="string">&quot;Hk4&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="number">24</span>);</span><br><span class="line">        <span class="type">User1</span> <span class="variable">u5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User1</span>(<span class="string">&quot;ak5&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="number">25</span>);</span><br><span class="line">        <span class="comment">//集合就是存储</span></span><br><span class="line">        List&lt;User1&gt; list = Arrays.asList(u1, u2, u3 ,u4 ,u5);</span><br><span class="line">        <span class="comment">//流来计算</span></span><br><span class="line">        list.stream()</span><br><span class="line">                .filter((u)-&gt;&#123; <span class="keyword">return</span> u.getAge()%<span class="number">2</span> == <span class="number">0</span>; &#125;)</span><br><span class="line">                .filter((u)-&gt;&#123; <span class="keyword">return</span> u.getAge() &gt; <span class="number">23</span>; &#125;)</span><br><span class="line">                .map((u)-&gt;&#123;<span class="keyword">return</span> u.getName().toUpperCase();&#125;)</span><br><span class="line">                .sorted((o1,o2)-&gt;&#123;<span class="keyword">return</span> o2.compareTo(o1);&#125;)</span><br><span class="line">                .limit(<span class="number">1</span>)</span><br><span class="line">                .forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User1</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String password;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork&#x2F;Join"></a>Fork&#x2F;Join</h1><p>基于<strong>分治算法</strong>（Divide and Conquer）思想。它通过将任务拆分为多个子任务并行执行，最终合并结果，来提高处理大规模数据的效率。</p>
<h3 id="核心类和机制"><a href="#核心类和机制" class="headerlink" title="核心类和机制"></a>核心类和机制</h3><h4 id="1-核心类"><a href="#1-核心类" class="headerlink" title="1. 核心类"></a>1. <strong>核心类</strong></h4><ul>
<li>**<code>ForkJoinPool</code>**：Fork&#x2F;Join 框架的线程池，负责管理任务的执行和工作线程的调度。</li>
<li>**<code>ForkJoinTask</code>**：任务的基类，定义了任务的执行行为。<ul>
<li>**<code>RecursiveTask&lt;V&gt;</code>**：用于有返回结果的任务。</li>
<li>**<code>RecursiveAction</code>**：用于没有返回结果的任务。</li>
</ul>
</li>
</ul>
<h4 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. <strong>工作原理</strong></h4><ul>
<li><strong>分解任务</strong>：使用 <code>fork()</code> 方法将任务拆分成子任务，并交给线程池中的工作线程。</li>
<li><strong>执行任务</strong>：子任务可以继续递归拆分，直到任务足够小，直接执行。</li>
<li><strong>合并结果</strong>：使用 <code>join()</code> 方法合并子任务的执行结果。</li>
</ul>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><h4 id="1-创建-ForkJoinPool"><a href="#1-创建-ForkJoinPool" class="headerlink" title="1. 创建 ForkJoinPool"></a>1. 创建 ForkJoinPool</h4><p>创建一个 <code>ForkJoinPool</code> 对象，作为任务的执行环境。</p>
<h4 id="2-定义任务"><a href="#2-定义任务" class="headerlink" title="2. 定义任务"></a>2. 定义任务</h4><p>继承 <code>RecursiveTask</code> 或 <code>RecursiveAction</code>，并实现 <code>compute()</code> 方法，定义任务的分解和合并逻辑。</p>
<h4 id="3-提交任务"><a href="#3-提交任务" class="headerlink" title="3. 提交任务"></a>3. 提交任务</h4><p>将任务提交到 <code>ForkJoinPool</code> 中执行。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**ForkJoin:并行执行任务</span></span><br><span class="line"><span class="comment"> * 特点：工作窃取</span></span><br><span class="line"><span class="comment"> * 维护的是双端队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//三种方式看执行效率</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoin</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        test1();</span><br><span class="line">        test2();</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通程序员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10_0000_0000</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;普通程序员用了&quot;</span> + (end - start)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中级程序员（ForkJoin）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(<span class="number">0L</span>, <span class="number">10_0000_0000L</span>);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> submit.get();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;中级程序员用了&quot;</span>+(end - start)+<span class="string">&quot;毫秒&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//高级程序员（Stream并行流）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">10_0000_0000L</span>)</span><br><span class="line">                .parallel()</span><br><span class="line">                .reduce(<span class="number">0</span>,Long::sum);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;高级程序员用了&quot;</span> + (end - start) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long start;</span><br><span class="line">    <span class="keyword">private</span> Long end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//临界值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">10000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForkJoinDemo</span><span class="params">(Long start, Long end)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>((end - start) &lt; temp)&#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Long</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//ForkJoin递归</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>; <span class="comment">//中间值</span></span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(start, middle);</span><br><span class="line">            task1.fork();<span class="comment">//拆分任务，把任务压入线程队列</span></span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(middle+<span class="number">1</span>, end);</span><br><span class="line">            task2.fork();<span class="comment">//拆分任务，把任务压入线程队列</span></span><br><span class="line">            <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>fork()</code></td>
<td>异步执行任务（将任务分配给工作线程）</td>
<td>异步执行，当前任务会在另一个线程执行。</td>
<td>任务拆分时，提交子任务。</td>
</tr>
<tr>
<td><code>join()</code></td>
<td>等待任务完成并获取结果</td>
<td>当前线程会阻塞，直到任务完成并返回结果。</td>
<td>获取异步任务的结果。</td>
</tr>
<tr>
<td><code>invoke()</code></td>
<td>提交任务并等待结果（同步）</td>
<td>同步提交任务，等待任务执行完毕并返回结果。</td>
<td>任务提交且需要立即获取结果。</td>
</tr>
<tr>
<td><code>submit()</code></td>
<td>提交任务并返回 <code>Future</code> 对象</td>
<td>提交任务，但不会等待任务完成。返回 <code>Future</code> 用于查询结果。</td>
<td>不需要立即结果，但需要任务执行状态。</td>
</tr>
<tr>
<td><code>execute()</code></td>
<td>提交一个无返回值的任务</td>
<td>无返回值，提交任务，通常用于副作用操作。</td>
<td>无需返回值，只需执行的任务。</td>
</tr>
<tr>
<td><code>compute()</code></td>
<td>执行具体的计算任务逻辑（在子类中实现）</td>
<td>在 <code>ForkJoinTask</code> 子类中实现，用于定义任务的执行逻辑。</td>
<td>子类中实现，任务的具体计算。</td>
</tr>
</tbody></table>
<h2 id="工作窃取"><a href="#工作窃取" class="headerlink" title="工作窃取"></a>工作窃取</h2><p>每个线程都有一个 <strong>双端队列（Deque）</strong> 用来存储任务。</p>
<p>线程首先尝试从自己的队列中取任务执行：</p>
<ul>
<li>从 <strong>队尾</strong> 获取任务（LIFO，即后进先出）。</li>
</ul>
<p>如果某个线程的任务完成了，而其他线程仍然有任务未完成：</p>
<ul>
<li>空闲线程会从其他线程的队列中 <strong>窃取任务</strong> 执行。</li>
<li>窃取的任务是从 <strong>队首</strong> 获取（FIFO，即先进先出）。</li>
</ul>
<p>工作窃取策略可以避免某些线程过载、某些线程闲置的情况，从而实现负载均衡。</p>
<h1 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h1><blockquote>
<p>Future设计的初衷：对将来的某个事件的结果进行建模 </p>
<p>Java 异步回调的实现方式：1. 基于接口的回调、2. 基于 Future 的回调、3. 基于 CompletableFuture</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步回调</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**异步调用:CompletableFuture</span></span><br><span class="line"><span class="comment"> * 异步执行-》成功回调-》失败回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsynchronousCallback</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//1、没有返回值的runAsync 异步调用</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;runAsync=&gt;void&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">        <span class="comment">//获得阻塞执行的结果  </span></span><br><span class="line">        completableFuture.get();<span class="comment">//等待异步任务完成</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、有返回值的SupplyAsync 异步回调</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;().supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;SupplyAsync=&gt;Integer&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(completableFuture.whenComplete((t,u)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t=&gt;&quot;</span>+t); <span class="comment">//正常的返回结果</span></span><br><span class="line">            System.out.println(<span class="string">&quot;u=&gt;&quot;</span>+u);<span class="comment">//错误信息</span></span><br><span class="line">        &#125;).exceptionally((e)-&gt;&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">233</span>;</span><br><span class="line">        &#125;).get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JMM-Java-Memory-Model"><a href="#JMM-Java-Memory-Model" class="headerlink" title="JMM(Java Memory Model)"></a>JMM(Java Memory Model)</h1><blockquote>
<p>Volatile的理解：</p>
<p><code>volatile</code> 是 Java 中的一个关键字，用于标识一个变量。在多线程环境下，<code>volatile</code> 确保了变量的 <strong>可见性</strong> 和 <strong>禁止指令重排</strong>。但它并<strong>不保证原子性。</strong></p>
</blockquote>
<p><strong>JMM</strong> 主要解决了多线程并发访问共享变量时出现的<strong>可见性</strong>、<strong>有序性</strong>和<strong>原子性</strong>问题。JMM是一个概念，约定。</p>
<h2 id="JMM同步约定："><a href="#JMM同步约定：" class="headerlink" title="JMM同步约定："></a><strong>JMM同步约定：</strong></h2><ul>
<li><p>线程解锁前，必须把共享变量立即刷回主内存。</p>
</li>
<li><p>线程枷锁前，必须读取主内存中最新值到工作内存中。</p>
</li>
<li><p>加锁和解锁是同一把锁</p>
</li>
</ul>
<h2 id="Java内存模型定义了8种操作来完成，虚拟机实现必须保证每一种操作都是原子的、不可再拆分的（double和long类型例外）。"><a href="#Java内存模型定义了8种操作来完成，虚拟机实现必须保证每一种操作都是原子的、不可再拆分的（double和long类型例外）。" class="headerlink" title="Java内存模型定义了8种操作来完成，虚拟机实现必须保证每一种操作都是原子的、不可再拆分的（double和long类型例外）。"></a><strong>Java内存模型定义了8种操作来完成，</strong>虚拟机实现必须保证每一种操作都是原子的、不可再拆分的（double和long类型例外）。</h2><ul>
<li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>
<li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<h2 id="8种操作必须满足的规则："><a href="#8种操作必须满足的规则：" class="headerlink" title="8种操作必须满足的规则："></a><strong>8种操作必须满足的规则：</strong></h2><ul>
<li>不允许read和load、store和write操作之一单独出现。即不允许一个变量从主内存读取了但工作内存不接受；或者从工作内存发起回写了但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它的最近的assign操作。即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存。</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li>
<li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</li>
</ul>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2022/01/15/kuangstudybd2424a7-c3ef-4cc7-89be-8c34650f3398.jpg" alt="img"></p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><blockquote>
<ol>
<li>保证可见性</li>
</ol>
</blockquote>
<p>下面这个程序无法停止，因为线程无法知道主线程中的变量已经改变了，所以需要volatile</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JMMDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 不加 volatile 程序就会死循环！</span></span><br><span class="line">    <span class="comment">// 加 volatile 可以保证可见性</span></span><br><span class="line">   <span class="comment">// private volatile static int num = 0;</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; <span class="comment">// main</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; <span class="comment">// 线程 1 对主内存的变化不知道的</span></span><br><span class="line">            <span class="keyword">while</span> (num==<span class="number">0</span>)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="2">
<li>不保证原子性</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vdemo02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        num++;<span class="comment">//不是原子操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)&#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">2</span>)&#123;<span class="comment">//因为程序里面始终是有2个线程的，main线程和gc线程</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">            <span class="comment">//Thread.yield()是在主线程中执行的，意思是还有GC和main之外的其他线程在跑，主线程就让出cpu不往下执行，让出然后重新竞争cpu的执行权</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//理论上打印出来应该是20000 但是num++不具有原子性 所以最终结果小于20000</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理论上打印出来应该是20000 但是num++不具有原子性 所以最终结果小于20000</p>
<p><strong>解决方法：</strong></p>
<ol>
<li>加synchronized或者加lock锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>不加lock和synchronized，怎么保证原子性？</strong></li>
</ol>
<p>num++不是原子操作，<strong>add()方法的JVM底层操作：</strong></p>
<p>第一步：获得 num的值<br>第二步： num的值加1<br>第三步： 写回num</p>
<p><img src="/.com//blog\source_posts\JUC并发编程\image-20250415204304176.png" alt="image-20250415204304176"></p>
<p><strong>使用原子类解决原子性问题</strong>：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b5ef586fceeb771e4ceff52edd25ddb8.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>  <span class="keyword">static</span> AtomicInteger num=<span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    num.getAndIncrement();</span><br><span class="line">    <span class="comment">//num=num+1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为原子类底层初始化的时候，将赋值给了一个volatile属性<br>原子类的底层都直接和操作系统挂钩，在内存中修改值，Unsafe类是很特殊的存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="3">
<li>禁止指令重排</li>
</ol>
</blockquote>
<p>什么是指令重排？：计算机不是按照你写的程序那样去执行</p>
<p>源代码执行前，编译器会进行优化，按照它所认为的高效的方式运行，指令并行也可能会重排，内存系统也会重排</p>
<p>处理器在进行指令重排的时候，会考虑数据之间的依赖性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;<span class="comment">//2</span></span><br><span class="line">x = x + <span class="number">5</span>;<span class="comment">//3</span></span><br><span class="line">y = x * x;<span class="comment">//4</span></span><br><span class="line">我们期望的执行顺序是：<span class="number">1234</span>  但是可能执行的时候顺序为： <span class="number">2134</span> <span class="number">1324</span></span><br><span class="line">    不可能是<span class="number">4123</span> 因为依赖性</span><br></pre></td></tr></table></figure>

<p>a b x y默认值为0：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3739ea67826b8a24d42824e863121f2b.png" alt="在这里插入图片描述"></p>
<p><strong>volatile可以避免指令重排：</strong></p>
<p>使用 <code>volatile</code> 修饰的变量，在其读写操作的前后会插入<strong>内存屏障（Memory Barrier）</strong>，从而限制指令重排。使用 <code>volatile</code> 修饰的变量，在其读写操作的前后会插入<strong>内存屏障（Memory Barrier）</strong>，从而限制指令重排。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">    a = <span class="number">1</span>;           <span class="comment">// 普通写操作</span></span><br><span class="line">    flag = <span class="literal">true</span>;     <span class="comment">// volatile 写操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;      <span class="comment">// volatile 读操作</span></span><br><span class="line">        System.out.println(a); <span class="comment">// 确保看到 a 的值为 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>volatile</code> 写操作</strong>：</p>
<ul>
<li>在 <code>flag = true;</code> 处，插入写屏障，确保 <code>a = 1;</code> 不会被重排到 <code>flag = true;</code> 之后。</li>
<li>也就是说，<code>a = 1</code> 必须在 <code>flag = true</code> 之前执行。</li>
</ul>
<p><strong><code>volatile</code> 读操作</strong>：</p>
<ul>
<li>在 <code>if (flag)</code> 处，插入读屏障，确保读到的 <code>flag</code> 是主内存中的最新值，同时之前的写操作 <code>a = 1</code> 对当前线程可见。</li>
</ul>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p><strong>单例模式（Singleton Pattern）</strong> 是一种常用的设计模式，属于创建型模式，目的是<strong>确保一个类只有一个实例，并提供一个全局访问点</strong>。它常用于需要控制资源共享的场景，例如线程池、数据库连接、全局缓存等。</p>
<h2 id="饿汉式（线程安全，立即加载）"><a href="#饿汉式（线程安全，立即加载）" class="headerlink" title="饿汉式（线程安全，立即加载）"></a>饿汉式（线程安全，立即加载）</h2><p>在类加载时就创建单例对象，线程安全，但可能会造成资源浪费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 在类加载时就初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">// 私有化构造器，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 提供公共的访问方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：简单实现，线程安全。</p>
<p><strong>缺点</strong>：类加载时就创建实例，即使未使用也会占用资源</p>
<h2 id="懒汉式（线程不安全，延迟加载）"><a href="#懒汉式（线程不安全，延迟加载）" class="headerlink" title="懒汉式（线程不安全，延迟加载）"></a>懒汉式（线程不安全，延迟加载）</h2><p>实例在第一次使用时创建，但多线程环境下可能存在问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();<span class="comment">//这个不是原子性操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：延迟加载，节约资源。</p>
<p><strong>缺点</strong>：在多线程环境下可能创建多个实例，不安全。</p>
<p>当有多个线程调用构造函数时，有可能出现多个Singleton对象，就不是单例了，所以不安全。</p>
<p>所以使用<strong>双重锁机制</strong>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMan</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyMan lazyman;<span class="comment">//还没有创建对象，只是声明，没有new</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//双重检测锁模式 DCL</span></span><br><span class="line">        <span class="keyword">if</span>(lazyman==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果为空，先上一层锁，锁LazyMan当前对象</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan.class)&#123;<span class="comment">//静态方法是类锁</span></span><br><span class="line">              <span class="comment">//如果synchronized直接写在方法上，所有线程都要抢锁，效率低，这个只有为空时才会抢锁</span></span><br><span class="line">                <span class="keyword">if</span>(lazyman==<span class="literal">null</span>)<span class="comment">//在锁里面再判断一次</span></span><br><span class="line">                &#123;</span><br><span class="line">                    lazyman=<span class="keyword">new</span> <span class="title class_">LazyMan</span>();<span class="comment">//如果这个对象为空，就实例化这个对象</span></span><br><span class="line">                    <span class="comment">//创建对象的过程在极端情况下肯定是会出现问题的，因为不是原子性操作，会经历</span></span><br><span class="line">                    <span class="comment">//1 分配内存空间，</span></span><br><span class="line">                    <span class="comment">//2执行构造方法（初始化对象）</span></span><br><span class="line">                    <span class="comment">//3把对象指向分配的空间</span></span><br><span class="line">                    <span class="comment">//这3个步骤</span></span><br><span class="line">                    <span class="comment">//可能会发生指令重排，很有可能A执行了13还没执行2，但是现在lazyman已经不是null了，如果现在进来一个B线程，外层判断不为空，那么B线程会直接返回lazyman，但lazyman实际上还没有完成构造，所以不安全（new只是把引用加上了，但是堆还没有创建完，return就会有问题），所以要用volatile修饰防止指令重排</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> lazyman;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">             LazyMan.getInstance();</span><br><span class="line">              <span class="comment">//  System.out.println(LazyMan.getInstance());</span></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这里是同步代码块保证了操作的原子性，volatile禁止了指令重排。</p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>利用类加载机制实现线程安全，同时支持延迟加载。<br>在一个类里面写一个静态的类<br>首先只要单例一定要先构造器私有<br>加载外部类时，不会加载静态内部类<br>线程安全且懒加载<br>但是静态内部类单例也是不安全的，因为反射可以破坏单例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：</p>
<ul>
<li>延迟加载：<code>SingletonHolder</code> 类只有在调用 <code>getInstance()</code> 时才会加载。</li>
<li>线程安全：类加载机制天然保证线程安全。</li>
</ul>
<p><strong>缺点</strong>：实现较为复杂。可以通过反射机制来破坏单例。</p>
<h2 id="枚举（最佳实践）"><a href="#枚举（最佳实践）" class="headerlink" title="枚举（最佳实践）"></a>枚举（最佳实践）</h2><p>枚举实现单例模式，防止反射和序列化攻击。枚举本身也是一个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingle</span> &#123;</span><br><span class="line">   INSTANCE;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> EnumSingle <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">         EnumSingle  instance1=EnumSingle.INSTANCE;</span><br><span class="line"><span class="comment">//         EnumSingle  instance2=EnumSingle.INSTANCE;</span></span><br><span class="line"><span class="comment">//         EnumSingle  instance3=EnumSingle.getInstance();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(null);</span></span><br><span class="line">         Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class,<span class="type">int</span>.class);<span class="comment">//这里的构造器在IDEA以及使用javap反编译出来看到的都是无参构造，使用jad可以发现是一个有参构造</span></span><br><span class="line">         declaredConstructor.setAccessible(<span class="literal">true</span>);<span class="comment">//先把构造器的私有权限破除，使得反射可以访问，创建对象</span></span><br><span class="line">         EnumSingle instance2= declaredConstructor.newInstance();</span><br><span class="line">         System.out.println( instance1);</span><br><span class="line">         System.out.println( instance2);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="CAS-Compare-And-Swap"><a href="#CAS-Compare-And-Swap" class="headerlink" title="CAS(Compare-And-Swap)"></a>CAS(Compare-And-Swap)</h1><p>是一种硬件级别支持的原子操作，常用于并发编程中实现无锁算法。它是一种<strong>乐观锁</strong>机制，假设不会发生冲突，通过不断重试来完成操作。</p>
<h2 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h2><p><code>Unsafe</code> 类是 Java 中一个用于直接操作内存和线程的底层工具类，位于 <code>sun.misc</code> 包中。它提供了许多低级别的操作能力，例如直接操作内存、CAS 操作、线程挂起和恢复等。<code>Unsafe</code> 类在 JDK 的实现中扮演重要角色，但它的使用被严格限制，且在一般开发中并不推荐使用。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ol>
<li><p><strong>非线程安全</strong>：<code>Unsafe</code> 是一个低级别工具，使用不当可能导致内存泄漏或程序崩溃。</p>
</li>
<li><p><strong>高性能</strong>：提供比普通 Java 操作更接近硬件的操作能力。</p>
</li>
<li><p><strong>限制访问</strong>：无法直接通过 <code>new</code> 实例化，只能通过反射获取。</p>
</li>
</ol>
<p>相当于Java操作内存的后门，Unsafe类里面有很多native方法</p>
<p><img src="/.com//blog\source_posts\JUC并发编程\image-20250423164126629.png" alt="image-20250423164126629"></p>
<h3 id="CAS-的基本思想"><a href="#CAS-的基本思想" class="headerlink" title="CAS 的基本思想"></a><strong>CAS 的基本思想</strong></h3><p><strong>CAS 是一种原子操作，包含三个关键要素：</strong></p>
<ol>
<li><strong>期望值（Expected Value）</strong>：期望内存中的某个值与当前值一致。</li>
<li><strong>新值（New Value）</strong>：如果期望值匹配，则将内存中的值更新为新值。</li>
<li><strong>内存位置（Memory Address）</strong>：要操作的变量的内存地址。</li>
</ol>
<p><strong>工作原理</strong>：</p>
<ul>
<li>CAS 比较内存地址中的值是否与期望值一致：<ul>
<li>如果一致，则将内存地址的值更新为新值，并返回操作成功。</li>
<li>如果不一致，则说明该值已经被其他线程修改过，操作失败，返回当前值。</li>
</ul>
</li>
</ul>
<h3 id="CAS-的实现方式"><a href="#CAS-的实现方式" class="headerlink" title="CAS 的实现方式"></a><strong>CAS 的实现方式</strong></h3><p>以下是 CAS 的伪代码逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">CAS</span><span class="params">(memoryAddress, expectedValue, newValue)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (memoryAddress.value == expectedValue) &#123;</span><br><span class="line">        memoryAddress.value = newValue;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 更新成功</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 更新失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 中，CAS 操作由 <code>sun.misc.Unsafe</code> 类的本地方法实现，底层依赖于处理器的 CAS 指令。<strong>JDK 的原子类（如 <code>AtomicInteger</code>、<code>AtomicLong</code> 等）都是基于 CAS 实现的。</strong></p>
<p><strong>示例：AtomicInteger</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 期望值为 5，新值为 10</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;操作结果：&quot;</span> + result); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前值：&quot;</span> + atomicInteger.get()); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次尝试，期望值为 5，新值为 20</span></span><br><span class="line">        result = atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;操作结果：&quot;</span> + result); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前值：&quot;</span> + atomicInteger.get()); <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CAS-的优缺点"><a href="#CAS-的优缺点" class="headerlink" title="CAS 的优缺点"></a><strong>CAS 的优缺点</strong></h2><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><strong>优点</strong>：</h4><ol>
<li><strong>高性能</strong>：无锁操作比传统的锁机制更高效，适合高并发场景。</li>
<li><strong>线程安全</strong>：CAS 是一种硬件级的原子操作，无需额外加锁即可实现线程安全。</li>
<li><strong>非阻塞</strong>：线程不会因为锁被占用而阻塞，提高系统吞吐量。</li>
</ol>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a><strong>缺点</strong>：</h4><ol>
<li><strong>ABA 问题</strong>：<ul>
<li>如果某个值从 <code>A</code> 改为 <code>B</code>，然后又改回 <code>A</code>，CAS 操作会误认为值没有改变。</li>
<li>解决方法：引入版本号（如 <code>AtomicStampedReference</code>）。</li>
</ul>
</li>
<li><strong>自旋消耗</strong>：<ul>
<li>CAS 在操作失败时会不断重试，自旋可能造成高 CPU 开销。</li>
</ul>
</li>
<li><strong>只能操作单个变量</strong>：<ul>
<li>无法直接对多个变量进行原子操作。</li>
</ul>
</li>
</ol>
<h2 id="ABA问题-原子引用解决ABA问题"><a href="#ABA问题-原子引用解决ABA问题" class="headerlink" title="ABA问题 &amp; 原子引用解决ABA问题"></a>ABA问题 &amp; 原子引用解决ABA问题</h2><p>一个捣乱的线程将变量改了之后又改回去，原线程可能并不知情，以为变量没有被修改，这不是我们期望的。</p>
<p><code>AtomicStampedReference</code> 是 Java 提供的一种解决 ABA 问题的工具类，通过版本号来判断值是否被修改过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABADemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp(); <span class="comment">// 获取当前版本号</span></span><br><span class="line">        System.out.println(<span class="string">&quot;初始版本号：&quot;</span> + stamp);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> atomicStampedReference.compareAndSet(<span class="number">1</span>, <span class="number">2</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;操作结果：&quot;</span> + result); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前值：&quot;</span> + atomicStampedReference.getReference());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前版本号：&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="各种锁的理解"><a href="#各种锁的理解" class="headerlink" title="各种锁的理解"></a>各种锁的理解</h1>
        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>XiaoLong Li</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://example.com/2025/04/13/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">http://example.com/2025/04/13/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Java/"># Java</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2025/04/27/Java%E5%85%AB%E8%82%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/">Java八股学习笔记(1)</a>
            
            
            <a class="next" rel="next" href="/2025/04/11/JVM/">JVM</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© XiaoLong Li | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>